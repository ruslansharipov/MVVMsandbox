# MVVMsandbox

ПРоект-исследование Jetpack библиотек и возможности перехода от Surf Android Standard на них с минимальными доработками.

## Структура
Пока что проект одномодульный, с разделением фич по пакетам в модуле app. 

## Архитектура

Используется привычный для Surf подход с Clean Architecture.

## DI

используется Dagger2, а точнее мультибайндинг.
В различных источниках привозятся примеры как сделать инжект непосредственно вьюмодели во фрагмент, с использованием Subcomponent, что в нашем случае не подходит, так как сильно ограничивает возможности переиспользования экранов - они могут переиспользоваться не только в рамках одной активити или другого фрагмент-контейнера. В случае использования Subcomponent'ов их родительские компоненты будут знать о дочерних компонентах и предоставлять билдеры для создания дочерних компонентов. 

Как это работает в нашем случае?
1. У класса вьюмодели проставляется @Inject constructor и dagger генерирует для него Provider<out ViewModel>
2. Этот провайдер кладется в генерируемый даггером Map<Class<out ViewModel>, Provider<ViewModel>>, который инжектится в фабрику, создающую вьюмодели (DaggerViewModelFactory.kt)

На примере экрана каталога это происходит в конфигураторе CategoriesScreenConfigurator в абстрактном модуле:
```kotlin
    @Module
    internal abstract class CategoriesViewModelModule {

        @Binds
        @IntoMap
        @ViewModelKey(CategoriesViewModel::class)
        abstract fun bindsFavoritesViewModel(viewModel: CategoriesViewModel): ViewModel
    }
```
3. Дальше мы можем инжектить эту фабрику во фрагмент или активити и доставать вьюмодель из провайдера уже во вью, а можем запровайдить через даггер ViewModelStore и извлекать вьюмодель из него уже в методах, которые провайдят вьюмодель. Но тут мы сталкиваемся с тем, что даггер нам уже сгенерировал Provider<CategoriesViewModel> и мы не можем провайдить CategoriesViewModel из модуля экрана, так как получится циклическая зависимость (даггер генерирует провайдер, который кладется в фабрику, а фабрика используется для того, чтобы получить вьюмодель с этом провайдере). Поэтому в нашем случае инжектится не сама вьюмодель, а ее интерфейс. 

```kotlin
        @Provides
        internal fun provideViewModel(
            viewModelStore: ViewModelStore,
            factory: DaggerViewModelFactory,
            route: CategoriesRoute
        ): ICategoriesViewModel { // Вот тут нельзя запровайдить CategoriesViewModel из-за возникновения цикла
            return ViewModelProvider(viewModelStore, factory).get(
                route.getId(),
                CategoriesViewModel::class.java
            )
        }
```

4. Так как у нас есть возможность переопределять метод Route.getId() то мы можем получать разные вьюмодели для разных экранов

Минусы: 
- нужно создавать и описывать интерфейс вьюмодели и из вью будет видно только то, что описано в этом интерфейсе.
- сложная схема с использованием даггера и мультибайндингов

Плюсы:
+ у нас всего одна фабрика, которая может быть использована во всем приложении, у нее нет скоупа, для каждого экрана она создается отдельная.
+ вьюмодель не надо доставать из хранилища во вью, она достается в модуле экрана
+ так как мы используем интерфейс - нам не нужно создавать дублирующие проперти для LiveData полей, чтобы подписываться на них из вью (например val users: LiveData<List<User>> и private val _users: MutableLiveData<List<User>>), мы просто в интерфейсе их описываем как LiveData, а в реализации используем MutableLiveData. Так что если сравнивать с гайдами, то получается даже круче

Конфигураторы можно генерировать как обычно мы генерируем сущности для экранов, так что их код писать не придется. 

## Фичи

Пока реализована только одна фича - Экран каталога по аналогии с экраном каталога из РИВ ГОШ.

При открытии экрана если в роут не были переданы подкатегории стартует запрос категорий (для наглядности используется задержка). Вью умеет отрисовывать три состояния этого запроса - загрузка, ошибка и успешное состояние.

По клику на элемент списка открывается новый экран каталога, которому в роут передаются подкатегории, так что новые экраны уже не загружают данные. 

При повороте экрана вьюмодели не пересоздаются - можно посмотреть логи.

**Видео работы экрана**

https://drive.google.com/file/d/11WPFWqCXuO3ryLasOA9jcBHKZhJnf-Gq/view?usp=sharing

## Запросы
Используется студийный мокер
https://r1.mocker.surfstudio.ru/files/mvvm_android_research/
